<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Dependency Injection on Posts</title><link>https://www.jacoelho.com/categories/dependency-injection/</link><description>Recent content in Dependency Injection on Posts</description><generator>Hugo</generator><language>en-us</language><copyright>&lt;a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener"&gt;CC BY-NC 4.0&lt;/a&gt;</copyright><lastBuildDate>Sun, 11 May 2025 10:00:00 +0000</lastBuildDate><atom:link href="https://www.jacoelho.com/categories/dependency-injection/index.xml" rel="self" type="application/rss+xml"/><item><title>Dependency Lifecycle Management in Go</title><link>https://www.jacoelho.com/blog/2025/05/dependency-lifecycle-management-in-go/</link><pubDate>Sun, 11 May 2025 10:00:00 +0000</pubDate><guid>https://www.jacoelho.com/blog/2025/05/dependency-lifecycle-management-in-go/</guid><description>&lt;h2 id="introduction"&gt;Introduction&lt;/h2&gt;
&lt;p&gt;Lifecycle management ensures that application components like servers, databases, and background workers are correctly initialized, started in the right order, and gracefully stopped.&lt;/p&gt;
&lt;p&gt;Go developers typically wire dependencies manually, instead of relying on heavy frameworks or reflection based dependency injection. This approach improves readability and reduces hidden behavior, but it also shifts the burden of managing component interactions and lifecycle sequencing onto the developer.&lt;/p&gt;
&lt;p&gt;As applications scale, the lack of built-in orchestration increases the risk of subtle bugs and inconsistent shutdown behavior.&lt;/p&gt;</description></item></channel></rss>