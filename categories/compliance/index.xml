<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Compliance on jacoelho - personal site</title>
    <link>https://www.jacoelho.com/categories/compliance/</link>
    <description>Recent content in Compliance on jacoelho - personal site</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <managingEditor>jose.alberto.coelho@gmail.com (jacoelho)</managingEditor>
    <webMaster>jose.alberto.coelho@gmail.com (jacoelho)</webMaster>
    <lastBuildDate>Fri, 20 Nov 2015 17:18:35 +0000</lastBuildDate>
    <atom:link href="https://www.jacoelho.com/categories/compliance/index.xml" rel="self" type="application/rss+xml" />
    
      
        
          <item>
            <title>redis</title>
            <link>https://www.jacoelho.com/blog/2015/11/20/redis/</link>
            <pubDate>Fri, 20 Nov 2015 17:18:35 +0000</pubDate>
            <author>jose.alberto.coelho@gmail.com (jacoelho)</author>
            <guid>https://www.jacoelho.com/blog/2015/11/20/redis/</guid>
            <description>

&lt;h1 id=&#34;secure-redis:aac08daf8601d2cee3108414db3a5691&#34;&gt;Secure Redis&lt;/h1&gt;

&lt;p&gt;Redis philosophy is that security is a second class citizen and should be implemented by a different layer. A recent post about this topic can be found here.
However, some of us have to abide by regulations like PCI DSS or HIPAA that impose strict restrictions on how communications should be done.
Our target will be a highly available redis setup with secure communication between nodes and its clients.&lt;/p&gt;

&lt;h2 id=&#34;topology:aac08daf8601d2cee3108414db3a5691&#34;&gt;Topology&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;media/redis-initial.png&#34; alt=&#34;topology&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;secure-communications:aac08daf8601d2cee3108414db3a5691&#34;&gt;Secure Communications&lt;/h2&gt;

&lt;p&gt;For the purpose of securing redis communications in the most transparent way, this setup will use ipsec in transport mode:&lt;/p&gt;

&lt;p&gt;Install required packages (debian):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ apt-get install ipsec-tools racoon
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Edit file &lt;em&gt;/etc/ipsec-tools.conf&lt;/em&gt; (configure a mesh):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/usr/sbin/setkey -f
flush;
spdflush;

spdadd 192.168.205.10/32 192.168.205.11/32 any -P in ipsec
  esp/transport//require;
spdadd 192.168.205.11/32 192.168.205.10/32 any -P out ipsec
  esp/transport//require;

spdadd 192.168.205.10/32 192.168.205.12/32 any -P in ipsec
  esp/transport//require;
spdadd 192.168.205.12/32 192.168.205.10/32 any -P out ipsec
  esp/transport//require;

spdadd 192.168.205.11/32 192.168.205.10/32 any -P in ipsec
  esp/transport//require;
spdadd 192.168.205.10/32 192.168.205.11/32 any -P out ipsec
  esp/transport//require;

spdadd 192.168.205.11/32 192.168.205.12/32 any -P in ipsec
  esp/transport//require;
spdadd 192.168.205.12/32 192.168.205.11/32 any -P out ipsec
  esp/transport//require;

spdadd 192.168.205.12/32 192.168.205.10/32 any -P in ipsec
  esp/transport//require;
spdadd 192.168.205.10/32 192.168.205.12/32 any -P out ipsec
  esp/transport//require;

spdadd 192.168.205.12/32 192.168.205.11/32 any -P in ipsec
  esp/transport//require;
spdadd 192.168.205.11/32 192.168.205.12/32 any -P out ipsec
  esp/transport//require;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Start the service:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;service setkey start
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Edit the file &lt;em&gt;/etc/racoon/racoon.conf&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;log notify;
path pre_shared_key &amp;quot;/etc/racoon/psk.txt&amp;quot;;

remote anonymous {
  exchange_mode main;
  proposal {
    encryption_algorithm aes_256;
    hash_algorithm sha1;
    authentication_method pre_shared_key;
    dh_group modp1024;
  }
  generate_policy off;
  lifetime time 12 hour;

}

sainfo anonymous{
  pfs_group 2;
  encryption_algorithm aes_256;
  authentication_algorithm hmac_sha1;
  compression_algorithm deflate;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Edit the file &lt;em&gt;/etc/racoon/psk.txt&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;192.168.205.10 securepassword
192.168.205.11 securepassword
192.168.205.12 securepassword
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Start the racoon service:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;service racoon restart
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If everything is ok we should be able to ping redis-1 from redis-2:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ping 192.168.205.10
PING 192.168.205.10 (192.168.205.10) 56(84) bytes of data.
64 bytes from 192.168.205.10: icmp_seq=1 ttl=64 time=0.058 ms
64 bytes from 192.168.205.10: icmp_seq=2 ttl=64 time=0.050 ms
64 bytes from 192.168.205.10: icmp_seq=3 ttl=64 time=0.048 ms
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Check with tcpdump that information is being encapsulated:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;3:45:50.132031 IP (tos 0x0, ttl 64, id 22902, offset 0, flags [DF], proto ESP (50), length 104)
192.168.205.10 &amp;gt; 192.168.205.11: ESP(spi=0x0957a438,seq=0xaa5), length 84
13:45:50.223091 IP (tos 0x0, ttl 64, id 17277, offset 0, flags [DF], proto ESP (50), length 104)
192.168.205.10 &amp;gt; 192.168.205.11: ESP(spi=0x0957a438,seq=0xaa6), length 84
13:45:50.223268 IP (tos 0x0, ttl 64, id 37527, offset 0, flags [DF], proto ESP (50), length 232)
192.168.205.10 &amp;gt; 192.168.205.11: ESP(spi=0x0957a438,seq=0xaa7), length 212
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Benchmark the connection without vpn:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ iperf -c 192.168.205.10 -t 60
— — — — — — — — — — — — — — — — — — — — — — — — — — — — — —
Client connecting to 192.168.205.10, TCP port 5001
TCP window size: 93.5 KByte (default)
— — — — — — — — — — — — — — — — — — — — — — — — — — — — — —
[ 3 ] local 192.168.205.11 port 33313 connected with 192.168.205.10 port 5001
[ ID ] Interval Transfer Bandwidth
[ 3 ] 0.0–60.0 sec 6.74 GBytes 965 Mbits/sec
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Benchmark the connection with vpn:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ iperf -c 192.168.205.10 -t 60
— — — — — — — — — — — — — — — — — — — — — — — — — — — — — —
Client connecting to 192.168.205.10, TCP port 5001
TCP window size: 85.0 KByte (default)
— — — — — — — — — — — — — — — — — — — — — — — — — — — — — —
[ 3 ] local 192.168.205.11 port 36091 connected with 192.168.205.10 port 5001
[ ID ] Interval Transfer Bandwidth
[ 3 ] 0.0–60.2 sec 357 MBytes 49.7 Mbits/sec
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Well that’s disappointing. I believe the culprit is related to the lack of support for the AES-NI instructions or with MTU:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;AVX2 or AES-NI instructions are not detected.
eth0: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc pfifo_fast state UP mode DEFAULT group default qlen 1000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s move on for now.&lt;/p&gt;

&lt;h2 id=&#34;configuring-redis-server:aac08daf8601d2cee3108414db3a5691&#34;&gt;Configuring Redis Server&lt;/h2&gt;

&lt;p&gt;Redis’s configuration is quite simple, we can ignore underlying network configuration.&lt;/p&gt;

&lt;p&gt;Install redis-server:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;apt-get install redis-server
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Edit redis-1 &lt;em&gt;/etc/redis/redis.conf&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bind 127.0.0.1 192.168.205.10
requirepass password
port 6379
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Edit redis-2 &lt;em&gt;/etc/redis/redis.conf&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bind 127.0.0.1 192.168.205.11
port 6379
slaveof 192.168.205.10 6379
masterauth password
requirepass password
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Edit redis-3 &lt;em&gt;/etc/redis/redis.conf&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bind 127.0.0.1 192.168.205.12
port 6379
slaveof 192.168.205.10 6379
masterauth password
requirepass password
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Start redis-server&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;service redis-server start
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Check wether everything is working:&lt;/p&gt;

&lt;p&gt;redis-1:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ redis-cli
127.0.0.1:6379&amp;gt; auth password
OK
127.0.0.1:6379&amp;gt; info replication
# Replication
role:master
connected_slaves:2
slave0:ip=192.168.205.12,port=6379,state=online,offset=105163101,lag=0
slave1:ip=192.168.205.11,port=6379,state=online,offset=105163242,lag=0
master_repl_offset:105163242
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:104114667
repl_backlog_histlen:1048576
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;redis-2 and redis-3:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ redis-cli
127.0.0.1:6379&amp;gt; auth password
OK
127.0.0.1:6379&amp;gt; info replication
# Replication
role:slave
master_host:192.168.205.10
master_port:6379
master_link_status:up
master_last_io_seconds_ago:1
master_sync_in_progress:0
slave_repl_offset:105161550
slave_priority:100
slave_read_only:1
connected_slaves:0
master_repl_offset:0
repl_backlog_active:0
repl_backlog_size:1048576
repl_backlog_first_byte_offset:0
repl_backlog_histlen:0
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;configuring-redis-sentinel:aac08daf8601d2cee3108414db3a5691&#34;&gt;Configuring Redis Sentinel&lt;/h2&gt;

&lt;p&gt;Redis Sentinel provides high availability for redis and will promote a slave to master if needed, among other tasks.&lt;/p&gt;

&lt;p&gt;On each node edit &lt;em&gt;/etc/redis/sentinel.conf&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sentinel monitor master 192.168.205.10 6379 2
sentinel auth-pass master password
sentinel down-after-milliseconds master 5000
sentinel failover-timeout master 5000
daemonize yes
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Start redis-sentinel service&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;service redis-sentinel start
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Validate:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ redis-cli -h 192.168.205.10 -p 26379 info
…
# Sentinel
sentinel_masters:1
sentinel_tilt:0
sentinel_running_scripts:0
sentinel_scripts_queue_length:0
master0:name=master,status=ok,address=192.168.205.10:6379,slaves=2,sentinels=3
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ redis-cli -h 192.168.205.10 -p 26379 sentinel sentinels master
1) 1) “name”
   2) “192.168.205.12:26379”
2) 1) “name”
   2) “192.168.205.11:26379”
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ redis-cli -h 192.168.205.10 -p 26379 sentinel slaves master
1) 1) “name”
   2) “192.168.205.11:6379”
2) 1) “name”
   2) “192.168.205.12:6379”
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we have achieved a highly available redis setup with secure communication between nodes.&lt;/p&gt;

&lt;h2 id=&#34;what-about-clients:aac08daf8601d2cee3108414db3a5691&#34;&gt;What about clients?&lt;/h2&gt;

&lt;p&gt;One possible configuration is adding the clients to the vpn. However the major downside would be reloading the vpn every time a new client is added or removed.
For the sake of completeness, client access will be over tls using stunnel. Stunnel will be listening on port 6380 and redirecting to 127.0.0.1:6379&lt;/p&gt;

&lt;p&gt;Install stunnel:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;apt-get install stunnel
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Edit the file &lt;em&gt;/etc/stunnel/stunnel.conf&lt;/em&gt;:&lt;/p&gt;

&lt;p&gt;redis-1:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;key = /etc/ssl/private/ssl-cert-snakeoil.key
cert = /etc/ssl/certs/ssl-cert-snakeoil.pem
sslVersion = TLSv1.2
options = NO_SSLv2
options = NO_SSLv3
socket = l:TCP_NODELAY=1
socket = r:TCP_NODELAY=1
[redis]
accept  = 192.168.205.10:6380
connect = 127.0.0.1:6379
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;redis-2:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;key  = /etc/ssl/private/ssl-cert-snakeoil.key
cert = /etc/ssl/certs/ssl-cert-snakeoil.pem
sslVersion = TLSv1.2
options = NO_SSLv2
options = NO_SSLv3
socket = l:TCP_NODELAY=1
socket = r:TCP_NODELAY=1
[redis]
accept  = 192.168.205.11:6380
connect = 127.0.0.1:6379
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;redis-3:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;key  = /etc/ssl/private/ssl-cert-snakeoil.key
cert = /etc/ssl/certs/ssl-cert-snakeoil.pem
sslVersion = TLSv1.2
options = NO_SSLv2
options = NO_SSLv3
socket = l:TCP_NODELAY=1
socket = r:TCP_NODELAY=1
[redis]
accept  = 192.168.205.12:6380
connect = 127.0.0.1:6379
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Start stunnel (stunnel4 on debian) service:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;service stunnel4 start
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Check if we can connect:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ openssl s_client -connect 192.168.205.10:6380
CONNECTED(00000003)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Obtaining the address of the current master:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ redis-cli -h 192.168.205.10 -p 26379 SENTINEL get-master-addr-by-name master
1) “192.168.205.10”
2) “6379”
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Redis sentinel knows nothing about stunnel and the reported master is running on port 6379, when we were expecting the 6380 (stunnel port).&lt;/p&gt;

&lt;h2 id=&#34;haproxy:aac08daf8601d2cee3108414db3a5691&#34;&gt;Haproxy&lt;/h2&gt;

&lt;p&gt;Since we can not use redis-sentinel to discover the active master, haproxy will do that job for us.&lt;/p&gt;

&lt;p&gt;Haproxy 1.5 or greater is needed.&lt;/p&gt;

&lt;p&gt;Edit file &lt;em&gt;/etc/haproxy/haproxy.conf&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;defaults REDIS
mode tcp
timeout connect 3s
timeout server 6s
timeout client 6s

frontend ft_redis
  bind *:6379 ssl crt /etc/haproxy/certificate.pem ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-DSS-AES128-GCM-SHA256:kEDH+AESGCM:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA:ECDHE-ECDSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-DSS-AES128-SHA256:DHE-RSA-AES256-SHA256:DHE-DSS-AES256-SHA:DHE-RSA-AES256-SHA:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!3DES:!MD5:!PSK
  default_backend bk_redis

backend bk_redis
  option tcp-check
  tcp-check connect
  tcp-check send AUTH\ password\r\n
  tcp-check expect string +OK
  tcp-check send PING\r\n
  tcp-check expect string +PONG
  tcp-check send info\ replication\r\n
  tcp-check expect string role:master
  tcp-check send QUIT\r\n
  tcp-check expect string +OK
  server redis1 192.168.205.10:6380 check-ssl inter 1s ssl verify none
  server redis2 192.168.205.11:6380 check-ssl inter 1s ssl verify none
  server redis3 192.168.205.12:6380 check-ssl inter 1s ssl verify none
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Client will need support for secure communications in the redis client or you will need to use stunnel.&lt;/p&gt;

&lt;h2 id=&#34;client-configuration:aac08daf8601d2cee3108414db3a5691&#34;&gt;Client Configuration&lt;/h2&gt;

&lt;p&gt;Edit the file &lt;em&gt;/etc/stunnel/stunnel.conf&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sslVersion = TLSv1.2
options = NO_SSLv2
options = NO_SSLv3
socket = l:TCP_NODELAY=1
socket = r:TCP_NODELAY=1
[redis]
client = yes
accept = 127.0.0.1:6379
connect = &amp;lt;haproxy ip&amp;gt;:6379
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And finally access the redis server:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ redis-cli -h 127.0.0.1
127.0.0.1:6379&amp;gt; auth password
OK
127.0.0.1:6379&amp;gt; info replication
# Replication
role:master
connected_slaves:2
slave0:ip=192.168.205.11,port=6379,state=online,offset=575891,lag=1
slave1:ip=192.168.205.12,port=6379,state=online,offset=575891,lag=0
master_repl_offset:575891
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:2
repl_backlog_histlen:575890
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;final-topology:aac08daf8601d2cee3108414db3a5691&#34;&gt;Final Topology&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;media/redis-final.png&#34; alt=&#34;final topology&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;conclusion:aac08daf8601d2cee3108414db3a5691&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Although the process described above is functional, it is still non trivial. If in the near future TLS support is included in redis, this might make matters easy.&lt;/p&gt;
</description>
          </item>
        
      
    
  </channel>
</rss>
